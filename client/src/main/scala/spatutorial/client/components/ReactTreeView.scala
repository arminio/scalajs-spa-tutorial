package spatutorial.client.components

import diode.react.{ModelProxy, ReactConnectProxy}
import japgolly.scalajs.react.CompScope._
import japgolly.scalajs.react._
import japgolly.scalajs.react.vdom.Builder
import japgolly.scalajs.react.vdom.prefix_<^._

import scala.scalajs.js



case class IdProvider(child: TagMod, id: String, searchString: String) extends TagMod{
//  val stringify = id //!@ beef this up to be generated by the component

  override def applyTo(b: Builder): Unit = child.applyTo(b)
}

object IdProvider {
  val empty = IdProvider(<.span("EMPTY EGG"), "no-id", "no-search-string")
}

/////////////////////////////////////////////
//case class IdProvider2(child: String, id: String, searchString: String) extends TagMod{
////  val stringify = id //!@ beef this up to be generated by the component
//
//  override def applyTo(b: Builder): Unit = child.applyTo(b)
//}

//object IdProvider2 {
//  val empty = IdProvider2("EMPTY EGG", "no-id", "no-search-string")
//}

case class TreeItem(item: IdProvider, children: TreeItem*) {
  def apply(item: IdProvider): TreeItem = TreeItem(item, Nil:_*)
}
//case class TreeItem(item: IdProvider , children: TreeItem*) {
//  def apply(item: Any): TreeItem = this(item, Nil)
//}

object ReactTreeView {

  trait Style {

    def reactTreeView = Seq[TagMod]()

    def treeGroup = Seq(^.margin := 0, ^.padding := "0 0 0 14px")

    def treeItem = Seq(^.listStyleType := "none")

    def selectedTreeItemContent = Seq( //^.backgroundColor := "#1B8EB0",
      ^.color := "blue", ^.fontWeight := 400,
      ^.padding := "0 19px")

    def treeItemBefore = Seq(
      ^.display := "inline-block",
      ^.fontSize := "11px",
      ^.color := "grey",
      ^.margin := "3px 7px 0 0",
      ^.textAlign := "center",
      ^.width := "11px"
    )

//    def treeItemHasChildrenClosed = Seq(^.contentStyle := "▶")
//
//    def treeItemHasChildrenOpened = Seq(^.contentStyle := "▼")

  }

  type NodeC = DuringCallbackU[NodeProps, NodeState, NodeBackend]

  case class State(treeItemConnector : ReactConnectProxy[TreeItem],
                    filterText: String,
                   filterMode: Boolean,
                   selectedNode: js.UndefOr[NodeC])

  class Backend($: BackendScope[Props, State]) {

    def onNodeSelect(P: Props)(selected: NodeC): Callback = {
      val removeSelection: Callback =
        $.state.flatMap(
          _.selectedNode
            .filterNot(_ == selected)
            .filter(_.isMounted())
            .fold(Callback.empty)(_.modState(_.copy(selected = false)))
        )

      val updateThis: Callback =
        $.modState(_.copy(selectedNode = selected, filterMode = false))

      val setSelection: Callback =
        selected.modState(_.copy(selected = true))

      val tell: Callback =
        P.onItemSelect.asCbo(
          selected.props.treeItemModelProxy.value.item.id,
          selected.props.parent,
          selected.props.depth
        )

      removeSelection >> updateThis >> setSelection >> tell
    }

    def onTextChange(text: String): Callback =
      $.modState(_.copy(filterText = text, filterMode = true))

    def render(P: Props, S: State) = {
      //!@println(s"ReactTreeView backend render.....")

        <.div(P.style.reactTreeView)(
          P.showSearchBox ?= ReactSearchBox(onTextChange = onTextChange),
          S.treeItemConnector((m: ModelProxy[TreeItem]) =>
            TreeNode.withKey("root")(NodeProps(
            treeItemModelProxy = m,
//            root         = m.value,
            open         = if (S.filterText.nonEmpty) true else P.open,
            onNodeSelect = onNodeSelect(P),
            filterText   = S.filterText,
            style        = P.style,
            filterMode   = S.filterMode
          ))
        )
        )


    }
  }

  case class NodeBackend($: BackendScope[NodeProps, NodeState]) {

    def onItemSelect(P: NodeProps)(e: ReactEventH): Callback =
      P.onNodeSelect($.asInstanceOf[NodeC]) >> e.preventDefaultCB >> e.stopPropagationCB

    def childrenFromProps(P: NodeProps): CallbackTo[Option[Unit]] =
      $.modState(S => S.copy(childrenWrapper =
        if (S.childrenWrapper.isEmpty)
          P.treeItemModelProxy.value.children.map(childTreeItem => P.treeItemModelProxy.connect(_ => childTreeItem))
        else Nil))
//      $.modState(S => S.copy(childrenWrapper = if (S.childrenWrapper2.isEmpty) P.treeItemModelProxy.value.children else Nil))
        .conditionally(P.treeItemModelProxy.value.children.nonEmpty)



    def onTreeMenuToggle(P: NodeProps)(e: ReactEventH): Callback =
      childrenFromProps(P) >> e.preventDefaultCB >> e.stopPropagationCB

    def isFilterTextExist(filterText: String, data: TreeItem): Boolean = {
      def matches(item: TreeItem): Boolean =
        item.item.searchString.toLowerCase.contains(filterText.toLowerCase)

      def loop(data: Seq[TreeItem]): Boolean =
        data.view.exists(
          item => if (item.children.isEmpty) matches(item) else loop(item.children)
        )

      matches(data) || loop(data.children)
    }

    def render(P: NodeProps, S: NodeState): ReactTag = {
      //!@println(s"ReactTreeView nodeBackend render children of root")
      val depth = P.depth + 1
      //      val parent   = P.root.item.id

      val parent = if (P.parent.isEmpty) P.treeItemModelProxy.value.item.id
      else s"${P.parent}<-${P.treeItemModelProxy.value.item.id}"


      val treeMenuToggle: TagMod =
        if (S.childrenWrapper.nonEmpty)
          <.a(
            ^.onClick ==> onTreeMenuToggle(P),
            ^.key := "arrow",
            P.style.treeItemBefore,
            //            "▼",
            //            Icon.arrowCircleDown2x,
            Icon.arrowCircleODown2x
          )
        else if (P.treeItemModelProxy.value.children.nonEmpty && S.childrenWrapper.isEmpty)
          <.a(
            ^.onClick ==> onTreeMenuToggle(P),
            ^.key := "arrow",
            P.style.treeItemBefore,
            //            "▶"
            Icon.arrowCircleORight2x
          )
        else ""

      println("1")
      <.li(
        P.style.treeItem,
        treeMenuToggle,
        ^.key := "toggle",
        ^.cursor := "pointer",
        <.span(
          S.selected ?= P.style.selectedTreeItemContent,
          ^.onClick ==> onItemSelect(P),
          //!@          P.root.item.toString
          P.treeItemModelProxy.value.item
        ),
        <.ul(P.style.treeGroup)(

          S.childrenWrapper.map((childConnector: ReactConnectProxy[TreeItem]) => {
            childConnector((childModelProxy: ModelProxy[TreeItem]) => {
              println("2")
              if (isFilterTextExist(P.filterText, childModelProxy.value)) {
                println("3")
                TreeNode.withKey(s"$parent$depth${childModelProxy.value.item}")(P.copy(
                  //                              root = child,
                  treeItemModelProxy = childModelProxy,
                  open = !P.filterText.trim.isEmpty,
                  depth = depth,
                  parent = parent,
                  filterText = P.filterText
                ))
              }              else
                <.span()

            })


          })
        )
      )
    }
  }

  case class NodeState(treeItemWrapper: ReactConnectProxy[TreeItem],
                       childrenWrapper: Seq[ReactConnectProxy[TreeItem]] = Nil,
                       selected: Boolean = false)

  case class NodeProps(treeItemModelProxy: ModelProxy[TreeItem],
                       open: Boolean,
                       depth: Int = 0,
                       parent: String = "",
                       onNodeSelect: (NodeC) => Callback,
                       filterText: String,
                       style: Style,
                       filterMode: Boolean)

  lazy val TreeNode = ReactComponentB[NodeProps]("ReactTreeNode")
    .initialState_P { P =>
      val reactConnectProxy = P.treeItemModelProxy.connect(identity)
      if (P.open) NodeState(reactConnectProxy , P.treeItemModelProxy.value.children.map(c => P.treeItemModelProxy.connect(_ => c))) else NodeState(reactConnectProxy)
    }
    .renderBackend[NodeBackend]
    .componentWillReceiveProps {
      case ComponentWillReceiveProps(_$, newProps) =>
        println(s"Tree node got new props: ${newProps.treeItemModelProxy.value.item}")
//        js.debugger()
//        _$.modState(_.copy(children = if (newProps.open) newProps.root.children else Nil))
        _$.modState(_.copy(childrenWrapper = if (newProps.open) newProps.treeItemModelProxy.value.children.map(c => newProps.treeItemModelProxy.connect(_ => c)) else Nil))
          .conditionally(newProps.filterMode)
          .void
    }
    .build

  val component = ReactComponentB[Props]("ReactTreeView")
    .initialState_P(p => State(p.proxy.connect(identity), "", true, js.undefined))
    .renderBackend[Backend]
    .build

  case class Props(proxy: ModelProxy[TreeItem],
                   open: Boolean,
                   onItemSelect: js.UndefOr[(String, String, Int) => Callback],
                   showSearchBox: Boolean,
                   style: Style)

  def apply(proxy: ModelProxy[TreeItem],
            openByDefault: Boolean = false,
            onItemSelect: js.UndefOr[(String, String, Int) => Callback] = js.undefined,
            showSearchBox: Boolean = false,
            ref: js.UndefOr[String] = js.undefined,
            key: js.UndefOr[js.Any] = js.undefined,
            style: Style = new Style {}) =
    component.set(key, ref)(Props(proxy, openByDefault, onItemSelect, showSearchBox, style))

}
